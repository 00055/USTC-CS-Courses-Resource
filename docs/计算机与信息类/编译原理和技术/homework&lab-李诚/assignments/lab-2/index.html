

<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">
    <link href="https://mbinary0.github.io/resource/github.markdown.css" rel="stylesheet">
  </head>
  <body>
     	<div><h2>
                <a href="../index.html">&nbsp;&nbsp;<i class="fa fa-level-up"></i>&nbsp;&nbsp;</a>:
                /<a href="../../../../../index.html"><i class="fa fa-home"></i></a>/<a href="../../../../index.html">计算机与信息类</a>/<a href="../../../index.html">编译原理和技术</a>/<a href="../../index.html">homework&lab-李诚</a>/<a href="../index.html">assignments</a>/<a href="index.html">lab-2</a>
            </h2>
        <div><span> 根据拼音排序</span></div>
        </div>
        <h2>Directories</h2>
        <ul>
        <li><i class="fa fa-meh-o"></i>&nbsp;None</li>
        </ul>

        <h2>Files</h2>
        <ul>
        <li><a href="https://raw.githubusercontent.com/mbinary/USTC-CS-Courses-Resource/master/计算机与信息类/编译原理和技术/homework&lab-李诚/assignments/lab-2/pl0语言语法图.pdf"><i class="fa fa-file-pdf-o"></i>&nbsp;pl0语言语法图.pdf---(65.83K)</a></li>
<li><a href="https://raw.githubusercontent.com/mbinary/USTC-CS-Courses-Resource/master/计算机与信息类/编译原理和技术/homework&lab-李诚/assignments/lab-2/README.md"><i class="fa fa-pencil-square-o"></i>&nbsp;README.md---(4.08K)</a></li>
        </ul>

        <div style="text-decration:underline;display:inline">
        <a href="https://github.com/mbinary/USTC-CS-Courses-Resource.git" target="_blank" rel="external"><i class="fa fa-github"></i>&nbsp; Github</a>
        <a href="mailto:&#122;huheqin1@gmail?subject=反馈与建议" style="float:right" target="_blank" rel="external"><i class="fa fa-envelope"></i>&nbsp; Feedback</a>
        </div>

        <blockquote> <p> 如果出现了 404, 说明此博客与 github repo 更新不同步, 你可以尽快联系我解决, 或者访问 github </p></blockquote>
        <h1 style="color:red;text-align:center;">Read Me</h1>

<p>﻿# Lab 2 Syntax Analysis</p>
<h2 id="1-goal">1 Goal</h2>
<ol>
<li>理解pl0语言的语法图</li>
<li>使用递归下降的方式测试语法的正确性</li>
<li>产生语法树</li>
<li>合理的错误检测</li>
</ol>
<h2 id="2-contents">2 Contents</h2>
<h3 id="21">2.1 理解语法图</h3>
<p>具体内容参照 pl0语言语法图.pdf</p>
<h3 id="22">2.2 递归下降分析</h3>
<p>在syntax/目录下已经实现一部分代码，包括</p>
<div class="codehilite"><pre><span></span>1. 符号表的定义以及操作（其中level在pl0_lex.h中定义，即`修改了lex中的文件`）
2. 程序体中const变量的定义声明的分析方式（观察语法图，很容易理解流程）
3. 其它函数的名称，以便自行填充
4. 修改了test.c文件，可做一定的测试
</pre></div>


<h3 id="23">2.3 产生语法树</h3>
<p>首先根据语法图推导出产生式，在递归下降的过程中，输出语法树<br />
举个例子<br />
1.对于已经在代码中实现的const变量的定义，我们通过语法图写出其对应的产生式如下：  </p>
<p>B &rarr; SB | &epsilon;<br />
S &rarr; C | M | N<br />
C &rarr; const V SEMICOLON<br />
V &rarr; ident EQU number E<br />
E &rarr; COMMA V | &epsilon;  </p>
<p>2.根据该产生式构造对应的FIRST和FOLLOW集合如下  </p>
<p>FIRST(B) = {const, &epsilon;}<br />
FIRST(S) = FIRST(C) = {const}<br />
FIRST(V) = {ident}<br />
FIRST(E) = {COMMA, &epsilon;}<br />
FOLLOW(B) = FOLLOW(S) = FOLLOW(C) = {$}<br />
FOLLOW(V) = FOLLOW(E) = {SEMICOLON}  </p>
<p>3.然后构造预测分析表如下  </p>
<table>
<thead>
<tr>
<th align="center">-</th>
<th align="center">const</th>
<th align="center">ident</th>
<th align="center">EQU</th>
<th align="center">number</th>
<th align="center">COMMA</th>
<th align="center">SEMICOLON</th>
<th align="center">$</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">B</td>
<td align="center">B &rarr; SB</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">B &rarr; &epsilon;</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">S &rarr; C</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">C</td>
<td align="center">C &rarr; const V SEMICOLON</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">V</td>
<td align="center">-</td>
<td align="center">V &rarr; ident EQU number E</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">E</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">E &rarr; COMMA V</td>
<td align="center">-</td>
<td align="center">E &rarr; &epsilon;</td>
</tr>
</tbody>
</table>
<p>4.根据预测分析表，将在分析过程中的栈按照一定的格式输出即可<br />
比如对于const y = 2;<br />
一种输出格式：（栈的变化）  </p>
<div class="codehilite"><pre><span></span>B
BS
BC
B SEMICOLON V const
B SEMICOLON V
B SEMICOLON E number EQU ident
B SEMICOLON E number EQU
B SEMICOLON E number
B SEMICOLON E
B SEMICOLON
B
</pre></div>


<p>另一种形式：（绘制语法树）  </p>
<div class="codehilite"><pre><span></span>graph TD;
    B--&gt;S;
    B--&gt;B.;
    S--&gt;C;
    C--&gt;const;
    C--&gt;V;
    C--&gt;SEMICOLON;
    V--&gt;ident;
    V--&gt;EQU;
    V--&gt;number;
</pre></div>


<h3 id="24">2.4 错误检测</h3>
<p>所谓的错误检测是指，当遇到一种错误的时候，语法分析的代码依然可以继续执行，继而找出更多的错误，直到整个代码分析结束</p>
<p>做错误检测可能用到pl0语言的FIRST和FOLLOW集合，以下给出</p>
<table>
<thead>
<tr>
<th align="center">非终结符(S)</th>
<th align="left">FIRST(S)</th>
<th align="left">FOLLOW(S)</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">程序体</td>
<td align="left">const var procedure ident call if begin while</td>
<td align="left">. ;</td>
</tr>
<tr>
<td align="center">语句</td>
<td align="left">ident call begin if while</td>
<td align="left">. ; end</td>
</tr>
<tr>
<td align="center">条件</td>
<td align="left">odd - ( ident number</td>
<td align="left">then do</td>
</tr>
<tr>
<td align="center">表达式</td>
<td align="left">ident number ( -</td>
<td align="left">. ; ) R end then do</td>
</tr>
<tr>
<td align="center">项</td>
<td align="left">ident number ( -</td>
<td align="left">. ; ) R + - end then do</td>
</tr>
<tr>
<td align="center">因子</td>
<td align="left">ident number ( -</td>
<td align="left">. ; ) R + - * / end then do</td>
</tr>
</tbody>
</table>
<ul>
<li>注：表中R代表6个关系运算符</li>
</ul>
<h2 id="3">3 编译运行</h2>
<p>编译方式和词法的一样，已经写好cmake相关文件，相关，命令如下</p>
<div class="codehilite"><pre><span></span>./do_cmake.sh
<span class="nb">cd</span> build
make
</pre></div>


<h2 id="4">4 提交检查</h2>
<ol>
<li>
<p>提交和lab-1类似，如何将lab-2的代码和自己本地修改过的lab-1的代码进行merge，请参照工作目录下的README.md中的<code>SYNCHRONIZING FORKS</code>  </p>
</li>
<li>
<p>需要做什么以及如何检查</p>
<blockquote>
<p>将pl0_tax.c中的空函数填充完整，根据语法图实现完整的语法分析代码<br />
最终提交的代码可以输出预测分析时栈的信息或者语法树，如2.3中介绍<br />
如果pl0代码中存在语法错误，完成后的代码可以进行错误检测，并且检测出所有错误  </p>
</blockquote>
</li>
<li>
<p>检查评分项</p>
</li>
<li>功能完善（能够分析test.pl）</li>
<li>根据语法图写出产生式（让助教清楚每个终结符，非终结符代表什么）</li>
<li>按照2.3中的要求产生语法树</li>
<li>错误检测<ul>
<li>程序正常结束（不因检测出一个错误而停止）</li>
<li>能够分析test_err.pl中的所有错误</li>
</ul>
</li>
</ol>
    </body>
</html>
